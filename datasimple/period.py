"""Helpers for time periods.

Our main contribution is the Period class for working with Period ranges and
adjusting prices with ICS rules and CPI."""

from collections import namedtuple
from datetime import datetime, timedelta


class Period(namedtuple('PeriodBase', ['year', 'month'])):
    """Year/month period tuple that can calculate price with CPI and exch adj.

    NOTE that before you call cpi or adj_price, you MUST call Period.init_cpi with
    parse result of reading our CPI JSON file that is generated by get_cpi.py.

    Exchange SO's are assumed to be fees calculated at EXCH_FEE_RATE of outright
    price. Change the default at your peril."""
    EXCH_FEE_RATE = 0.10
    CPI_REF = None
    CURR_PERIOD = None

    @staticmethod
    def from_dt(dt):
        if type(dt) is str:
            dt = datetime.strptime(dt, '%m/%d/%y')
        return Period(int(dt.year), int(dt.month))

    @classmethod
    def init_cpi(cls, cpi_json):
        """One time init for CPI lookup from a JSON list."""
        cpi_ref = dict()
        for rec in cpi_json:
            y = int(rec['Year'])
            m = int(rec['Month'])
            cpi = float(rec['CPI'])
            assert cpi > 0.0, 'Non-positive CPI found!'

            p = Period(y, m)
            assert p not in cpi_ref, 'Duplicate Period found!'
            cpi_ref[p] = cpi

        cls.CURR_PERIOD = Period.from_dt(datetime.now())
        assert cls.CURR_PERIOD in cpi_ref, 'CPI reference does not have current period'

        # All done - save init
        cls.CPI_REF = cpi_ref

    def prev_period(self):
        """Return period that follows current period."""
        return Period.from_dt(
            datetime(self.year, self.month, 1) - timedelta(days=3)
        )

    def next_period(self):
        """Return period that follows current period."""
        return Period.from_dt(
            datetime(self.year, self.month, 1) + timedelta(days=33)
        )

    def window_end(self):
        """Return period ending the window begun by current period."""
        # Walk forward a year and then step back a period: remember that a 12 month
        # window that starts with Jan 2016 would end with period Dec 2016
        return Period.from_dt(
            datetime(self.year, self.month, 1) + timedelta(days=368)
        ).prev_period()

    def window(self):
        """Generator yielding all periods in window from current."""
        curr, end = self, self.window_end()
        while curr <= end:
            yield curr
            curr = curr.next_period()

    def cpi(self):
        """Return CPI for current period."""
        assert self.CPI_REF, 'BUG: CPI reference not initialized'
        return self.CPI_REF[self]

    def adj_price(self, price, so_type):
        """Give a final adjusted price for the period relative to CURR_PERIOD."""
        price = float(price)
        assert price > 0.0, 'Price must be positive float'

        # Verify SO type and convert exchange fee to est outright price
        so_type = str(so_type).strip().upper()
        if so_type in {'CE', 'FE'}:
            price /= self.EXCH_FEE_RATE
        elif so_type not in {'SO'}:
            raise ValueError('Unknown SO Type {}'.format(so_type))

        # Now convert to current period dollars
        src_cpi = self.cpi()
        assert src_cpi > 0.0, 'Source CPI must be positive'
        now_cpi = self.CURR_PERIOD.cpi()
        assert src_cpi > 0.0, 'Current period CPI must be positive'

        return price * (now_cpi / src_cpi)
